<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>A Decade of DDD, CQRS and Event Sourcing | Anes Hasicic</title><meta name=keywords content="event sourcing,ddd,cqrs,event modeling,event storming"><meta name=description content="For those that haven’t really moved past the blue book…
DDD for many, including me, brought back the enjoyment of software development. Implementation becomes easy when you break down the domain. The bits and pieces suddenly start to “fit” together in a way they did not before, and the implementation itself becomes straight-forward which results in a simple, maintainable and easy to understand code that will outlive the development team itself."><meta name=author content><link rel=canonical href=https://anes.io/posts/a-decade-of-ddd-cqrs-and-event-sourcing/><link crossorigin=anonymous href=/assets/css/stylesheet.d7fb4cbf980fe688a21621b06a795933c4e6bb2d4070ec940667af1715d84af2.css integrity="sha256-1/tMv5gP5oiiFiGwanlZM8Tmuy1AcOyUBmevFxXYSvI=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://anes.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://anes.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://anes.io/favicon-32x32.png><link rel=apple-touch-icon href=https://anes.io/apple-touch-icon.png><link rel=mask-icon href=https://anes.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-6ZMV8R5VLT"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-6ZMV8R5VLT',{anonymize_ip:!1})}</script><meta property="og:title" content="A Decade of DDD, CQRS and Event Sourcing"><meta property="og:description" content="For those that haven’t really moved past the blue book…
DDD for many, including me, brought back the enjoyment of software development. Implementation becomes easy when you break down the domain. The bits and pieces suddenly start to “fit” together in a way they did not before, and the implementation itself becomes straight-forward which results in a simple, maintainable and easy to understand code that will outlive the development team itself."><meta property="og:type" content="article"><meta property="og:url" content="https://anes.io/posts/a-decade-of-ddd-cqrs-and-event-sourcing/"><meta property="og:image" content="https://anes.io/posts/ddd.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-02-22T00:00:00+00:00"><meta property="article:modified_time" content="2019-02-22T00:00:00+00:00"><meta property="og:site_name" content="Anes Hasicic"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://anes.io/posts/ddd.png"><meta name=twitter:title content="A Decade of DDD, CQRS and Event Sourcing"><meta name=twitter:description content="For those that haven’t really moved past the blue book…
DDD for many, including me, brought back the enjoyment of software development. Implementation becomes easy when you break down the domain. The bits and pieces suddenly start to “fit” together in a way they did not before, and the implementation itself becomes straight-forward which results in a simple, maintainable and easy to understand code that will outlive the development team itself."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://anes.io/posts/"},{"@type":"ListItem","position":2,"name":"A Decade of DDD, CQRS and Event Sourcing","item":"https://anes.io/posts/a-decade-of-ddd-cqrs-and-event-sourcing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"A Decade of DDD, CQRS and Event Sourcing","name":"A Decade of DDD, CQRS and Event Sourcing","description":"For those that haven’t really moved past the blue book…\nDDD for many, including me, brought back the enjoyment of software development. Implementation becomes easy when you break down the domain. The bits and pieces suddenly start to “fit” together in a way they did not before, and the implementation itself becomes straight-forward which results in a simple, maintainable and easy to understand code that will outlive the development team itself.","keywords":["event sourcing","ddd","cqrs","event modeling","event storming"],"articleBody":" For those that haven’t really moved past the blue book…\nDDD for many, including me, brought back the enjoyment of software development. Implementation becomes easy when you break down the domain. The bits and pieces suddenly start to “fit” together in a way they did not before, and the implementation itself becomes straight-forward which results in a simple, maintainable and easy to understand code that will outlive the development team itself.\nDDD has come a long way since “the blue book”, but in my experience, not enough people realize that DDD is a growing, evolving thing and that it has indeed learned a few new tricks along the way. This blog is a brief recap of some of the notable things that happened in the DDD community during the last decade or so.\nCan I DDD? First things first. What do you need exactly to successfully implement DDD? What are the prerequisites without which it wouldn’t be feasible?\nAccording to Eric Evans, there are two main ones:\nIterative development process Access to domain experts Iterative development is a life force of DDD. It enables experimentation, exploration, and calls for active refactoring of the problem domain as you continue to gain more insight alongside your domain experts. Additionally, you are making use of tight feedback loops which involve feedback obtained through the actual usage of the system that is being constructed.\nWhen you really come to think about it, what are the odds that you have discovered the “best” model for your domain the first time? Even the first couple of times?\nThe chances are pretty slim. Especially so due to the fact that there is no such thing as “the perfect” model for almost anything that you might be modeling.\nOne of the significant mistakes we all do is, slipping towards perfectionism. As we already made clear, DDD depends on iteration, so don’t get caught up in the details too early. Do the first prototype quickly, then get to the second one quick etc…\nPerfect is the enemy of good and perfectionism prevents you from doing enough innovation.\nWith that being said, don’t settle for the first useful model you may encounter. Keep iterating and always rigorously refine and keep watching for even the most innocent looking workarounds. They are an indication of a non-optimal model, and it’s almost certain that you have missed a modeling opportunity somewhere along the way.\nIterative development approach makes heavy use of domain experts. It’s hard to have one without the other, and missing out on any of those will most certainly make your DDD efforts futile.\nAt this point, you might be thinking: “Well, what about DDD lite?” It provides me with a lot of useful abstractions and modeling tools. Couldn’t I get away by just using the tools and abstractions that DDD lite approach provides?\nSorry, but, the answer is no. DDD Lite can only get you so far due to its nature. It provides a set of modeling tools/building blocks (e.g. entities, repositories, value objects etc…) which will help you implement DDD itself! By only using DDD lite, you actually miss out on DDD altogether…\nWhat use are all of the abstractions and modeling tools, if you don’t have a good idea of what you are building, or even worse… If you are building the wrong thing?\nExplicit context boundaries and the Core Domain Focusing on the Core Domain, as Eric puts it, is a game changer.\nFocus your DDD efforts on your Core Domain. The stuff that really makes your company stand out from the competition. The thing that gives you an edge and a competitive advantage on the market.\nCompanies can waste so much time, money and effort by reinventing the wheel and applying DDD to the parts of their domain that could have gotten away with a more simplistic approach or even be replaced by existing, off the shelf solutions.\nBut, in order to identify your true core domain, you will need to define explicit context boundaries through any of the context mapping techniques (I suggest you look up Event Storming, more about it later…).\nWith all of this being said, it takes a certain level of discipline to keep separation between bounded contexts, but it yields great benefits and almost any project whether it makes use of DDD or not, big or small, can benefit off of context mapping and having explicitly defined context boundaries which will separate really important parts of the domain, from the less important ones, and will ultimately help you identify your Core Domain, and that’s where most of your DDD efforts need to be directed.\nContext mapping and the big ball of mud What do you do if you are dealing with a legacy system, a big ball of mud? How do you get a taste of DDD there (assuming you still can employ iterative development approach, and have access to domain experts)?\nWell, just because the legacy system aka. “the big ball of mud” exists, it does not mean you have to keep cramping it with new features, but rather, employ your context mapping techniques here. Draw a line around it and say, “this is my big ball of mud”, and after that draw a line around your new service and treat it as a separate bounded context.\nAs Eric puts it, it’s probably inevitable that your service will get enclosed by the big ball of mud eventually (since it will eat almost anything), but at least you had a nice run for a time.\nA word on DDD building blocks Building blocks (Entities, Value Objects, Factories, Repositories …) are overemphasized! — Eric Evans\nYes, you heard it right. Building blocks have gotten too much attention, but don’t get me wrong, they are still important and provide a great value. Building blocks are what they are. They are a means to an end, mere implementation details that help you implement strategic DDD patterns.\nAs Evans stated, he regrets putting the strategic patterns way back at the end of the book, which probably resulted in many people giving more importance to the tactical patterns because they come first or even worse, they get so caught up in the intricate implementation details of tactical patterns, they don’t even get to the most important part of the book.\nThe thing to take away is that building blocks provide you the tools to implement DDD, but you should give much more focus to strategic patterns, even more so because tactical patterns/building blocks will continue to evolve, some will become obsolete, new ones will be added (eg. Domain Events).\nAggregates Aggregate represents a conceptual whole in the domain that is also consisted of other small parts (Value Objects and/or other Entities) and protects an always consistent invariant across all of them.\nOne question that pops up often is a concern that a lot of people have regarding the awkward cases where their aggregates have an invariant that crosses thousands of entities.\nSince we can access a child entity only through its parent aggregate, do we load all of them each time we load an aggregate? Do we make use of lazy loading? Do we model this differently even though it’s a business invariant? If yes, what’s the correct model for this?\nThe bottom line is that OO is really not good at handling collections of objects, especially very large collections, which calls for loosening and “bending” the rules a bit in these cases.\nThe same applies if you have a small number of aggregates but have a lot of concurrent users that might be interacting with the aggregate at the same time.\nIn cases like these, you might consider modeling those entities as separate aggregate(s) and try enforcing the business invariant on a higher level. For example, in domain services, process managers/sagas etc… In short, make the consistency an explicit concern of your domain instead of it being solved implicitly through the infrastructure.\nAs it turns out, another potential solution is related to another question/concern that keeps popping up when working on a project that makes use of CQRS as a standalone pattern or in a combination with Event Sourcing.\nCan write side query the read side?\nAccording to Greg Young, the answer is yes, absolutely, there are cases when you simply have to, and one of those cases is related to the challenge we mentioned here.\nI’d argue that even if you don’t face the aggregates/entities problem we describe here, there are a lot of cases where it’s OK to query the read side (I have certainly done it more than once).\nIt’s fairly easy to spot these opportunities because in majority (if not all) of the cases they tend to present themselves in a form of a specification pattern, but since you are using Event Sourcing or CQRS as a standalone pattern, you can’t really make use of them. But luckily for you, specifications and CQRS are two competing/interchangeable patterns.\nRule of thumb would be to aim for very small and very specific projections which can provide you with a very specific answer to a very specific question which would be very cumbersome to implement by querying domain models.\nVaughn Vernon has a lot to say about aggregate design. Check out his two-part Aggregate Design paper:\nEffective Aggregate Design Part I Effective Aggregate Design Part II I also highly recommend you check out his DDD book: Implementing Domain-Driven Design\nDDD in a modern “always on” world Software applications outside of the enterprise world, in general, have quite different requirements in terms of performance, latency, responsiveness, and scalability. There was a fear that applying DDD patterns to these kinds of domains would not really be feasible due to the aforementioned constraints and the overhead that OOP with DDD applied would introduce.\nThis might have been a great obstacle to widespread DDD adoption, but luckily, applying DDD to these kinds of domains gave birth to a new approach (the ideas were there for centuries actually) towards applying DDD under the name of Event Sourcing and CQRS.\nIn short, Event Sourcing and it’s complementary pattern, CQRS gave us an extravagant revamp of DDD building blocks, and a way to employ DDD patterns through the use of Domain Events as first-class citizens and the sole source of truth in these kinds of systems, while at the same time allowing us to satisfy high throughput / high availability needs of those kinds of systems, by enabling us to scale reads and writes separately, and employ inter-service integration via Domain Events.\nEvent Sourcing also provides a stepping stone towards implementing DDD in a functional world, due to the immutable nature of its event streams (An aggregate state is a left fold of all of its events).\nBut meeting scalability demands of large distributed systems is not the only benefit of employing this kind of event-centric approach towards modeling our systems.\nThere are a number of other benefits of employing an event-first modeling approach:\nExplicitly modeling important domain events and formalizing them, forces domain experts to think in terms of the behavior of their system instead of in terms of its structure. This especially helps, since people tend to think in terms of their legacy systems, instead of focusing on the problem they are really trying to solve. By modeling events, and focusing on the behaviors instead of nouns, even the domain experts get a different perspective on their domain and gain additional insight. Event modeling forces temporal focus and makes time become a crucial factor (which it is) If any of these resonate with you I encourage you to check out Event Storming by Alberto Brandolini. Event Storming employs an event-centric approach in order to distill the domain.\nI won’t go into detail here, but I will just mention that Event Storming has a number of different flavors you will find on the site and the book but, I would like to mention one more variant by Greg Young.\nIn his variant, you basically just take one single long-running business process end to end and model it using Event Storming in order to discover your service boundaries. This worked very well for me.\nEvent Sourcing and CQRS misconceptions/pain points During one of his talks, Young focused on some recurring pain points/misconceptions that were coming up repeatedly regarding Event Sourcing and CQRS, and offered clarification and advice on how to approach these …. Here is a short recap.\nCQRS is not a top-level architecture!\nCQRS is a supporting pattern and you need to treat it as such. Don’t go crazy! Instead, apply it selectively to a few places.\nCommands must return void?!\nThe bottom line is that it’s not about return values, it’s rather about side effects? It is perfectly OK for commands to return the list of errors example, instead of relying only on throwing exceptions (which is a bit of a bad practice anyway).\nCommand vs Domain Event is not strictly a one on one relationship!\nAn event does not necessarily have a corresponding command, nor does a command have exactly one corresponding event being published. It is important to understand that there are always two sets of use cases. The commands coming in and the events coming out.\nAn event is not strictly a result of a command coming in. In event-centric architectures, this is commonplace to see, and the whole point of it is that events cause stuff to happen. A business process that resulted in publishing a domain event is often time triggered by another event without any commands.\nThere is no such thing as one way / async Command\nThe whole point of a command is that I have the ability to tell you No!\n“Async” commands don’t really give you that option, you just fire and forget, which is kind of defeating the purpose. They do not work well in the real world.\nBy accepting a command, it should mean that you validated it, you can execute it, you processed it and it’s done. Otherwise, what you really want is a downstream event processor.\nDon’t write a CQRS / Event Sourcing framework. Period.\nI think we need to start realizing that you do not need a framework for everything. Frameworks have their place, but we need to put an end to framework-first mindset and instead, try to solve our problems with focused modules/libraries instead of relying on almost always “too generic” frameworks which tend to sprawl their tentacles all over our code base.\nWe need better examples!\nAs Greg puts it, we need better examples. Event Sourcing is hard, that’s a fact, and simple examples like simplified shopping cards don’t really do it justice.\nRecommended training material:\nDomain-Driven Design Distilled Implementing Domain-Driven Design Event Storming Event Storming Book Microservices Patterns: With examples in Java Confluent Microservices blog series Lightbend Courses How Events Are Reshaping Modern Systems This blog has also been published at tacta.io\n","wordCount":"2490","inLanguage":"en","image":"https://anes.io/posts/ddd.png","datePublished":"2019-02-22T00:00:00Z","dateModified":"2019-02-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://anes.io/posts/a-decade-of-ddd-cqrs-and-event-sourcing/"},"publisher":{"@type":"Organization","name":"Anes Hasicic","logo":{"@type":"ImageObject","url":"https://anes.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://anes.io/ accesskey=h title="Anes Hasicic (Alt + H)">Anes Hasicic</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://anes.io/>Home</a>&nbsp;»&nbsp;<a href=https://anes.io/posts/>Posts</a></div><h1 class=post-title>A Decade of DDD, CQRS and Event Sourcing</h1><div class=post-meta><span title='2019-02-22 00:00:00 +0000 UTC'>February 22, 2019</span>&nbsp;·&nbsp;12 min</div></header><figure class=entry-cover><img loading=lazy src=https://anes.io/posts/ddd.png alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#can-i-ddd aria-label="Can I DDD?">Can I DDD?</a></li><li><a href=#explicit-context-boundaries-and-the-core-domain aria-label="Explicit context boundaries and the Core Domain">Explicit context boundaries and the Core Domain</a></li><li><a href=#context-mapping-and-the-big-ball-of-mud aria-label="Context mapping and the big ball of mud">Context mapping and the big ball of mud</a></li><li><a href=#a-word-on-ddd-building-blocks aria-label="A word on DDD building blocks">A word on DDD building blocks</a></li><li><a href=#aggregates aria-label=Aggregates>Aggregates</a></li><li><a href=#ddd-in-a-modern-always-on-world aria-label="DDD in a modern “always on” world">DDD in a modern “always on” world</a></li><li><a href=#event-sourcing-and-cqrs-misconceptionspain-points aria-label="Event Sourcing and CQRS misconceptions/pain points">Event Sourcing and CQRS misconceptions/pain points</a></li></ul></div></details></div><div class=post-content><blockquote><p>For those that haven’t really moved past the blue book…</p></blockquote><p>DDD for many, including me, brought back the enjoyment of software development. Implementation becomes easy when you break down the domain. The bits and pieces suddenly start to “fit” together in a way they did not before, and the implementation itself becomes straight-forward which results in a simple, maintainable and easy to understand code that will outlive the development team itself.</p><p>DDD has come a long way since “the blue book”, but in my experience, not enough people realize that DDD is a growing, evolving thing and that it has indeed learned a few new tricks along the way. This blog is a brief recap of some of the notable things that happened in the DDD community during the last decade or so.</p><h2 id=can-i-ddd>Can I DDD?<a hidden class=anchor aria-hidden=true href=#can-i-ddd>#</a></h2><p>First things first. What do you need exactly to successfully implement DDD? What are the prerequisites without which it wouldn’t be feasible?</p><p>According to Eric Evans, there are two main ones:</p><ul><li>Iterative development process</li><li>Access to domain experts</li></ul><p>Iterative development is a life force of DDD. It enables experimentation, exploration, and calls for active refactoring of the problem domain as you continue to gain more insight alongside your domain experts. Additionally, you are making use of tight feedback loops which involve feedback obtained through the actual usage of the system that is being constructed.</p><p>When you really come to think about it, what are the odds that you have discovered the “best” model for your domain the first time? Even the first couple of times?</p><p>The chances are pretty slim. Especially so due to the fact that there is no such thing as “the perfect” model for almost anything that you might be modeling.</p><p>One of the significant mistakes we all do is, <strong>slipping towards perfectionism</strong>. As we already made clear, DDD depends on iteration, so don’t get caught up in the details too early. Do the first prototype quickly, then get to the second one quick etc…</p><p><strong>Perfect is the enemy of good</strong> and perfectionism prevents you from doing enough innovation.</p><p>With that being said, don’t settle for the first useful model you may encounter. Keep iterating and always rigorously refine and keep watching for even the most innocent looking workarounds. They are an indication of a non-optimal model, and it’s almost certain that you have missed a modeling opportunity somewhere along the way.</p><p>Iterative development approach makes heavy use of domain experts. It’s hard to have one without the other, and missing out on any of those will most certainly make your DDD efforts futile.</p><p>At this point, you might be thinking: “Well, what about DDD lite?” It provides me with a lot of useful abstractions and modeling tools. Couldn’t I get away by just using the tools and abstractions that DDD lite approach provides?</p><p>Sorry, but, the answer is no. DDD Lite can only get you so far due to its nature. It provides a set of modeling tools/building blocks (e.g. entities, repositories, value objects etc…) which will help you implement DDD itself! By only using DDD lite, you actually miss out on DDD altogether…</p><p>What use are all of the abstractions and modeling tools, if you don’t have a good idea of what you are building, or even worse… If you are building the wrong thing?</p><h2 id=explicit-context-boundaries-and-the-core-domain>Explicit context boundaries and the Core Domain<a hidden class=anchor aria-hidden=true href=#explicit-context-boundaries-and-the-core-domain>#</a></h2><p>Focusing on the <strong>Core Domain</strong>, as Eric puts it, is a game changer.</p><p>Focus your DDD efforts on your Core Domain. The stuff that really makes your company stand out from the competition. The thing that gives you an edge and a competitive advantage on the market.</p><p>Companies can waste so much time, money and effort by reinventing the wheel and applying DDD to the parts of their domain that could have gotten away with a more simplistic approach or even be replaced by existing, off the shelf solutions.</p><p>But, in order to identify your true core domain, you will need to define <strong>explicit context boundaries</strong> through any of the context mapping techniques (I suggest you look up <strong>Event Storming</strong>, more about it later…).</p><p>With all of this being said, it takes a certain level of discipline to keep separation between bounded contexts, but it yields great benefits and almost any project whether it makes use of DDD or not, big or small, can benefit off of context mapping and having explicitly defined context boundaries which will separate really important parts of the domain, from the less important ones, and will ultimately help you identify your Core Domain, and that’s where most of your DDD efforts need to be directed.</p><h2 id=context-mapping-and-the-big-ball-of-mud>Context mapping and the big ball of mud<a hidden class=anchor aria-hidden=true href=#context-mapping-and-the-big-ball-of-mud>#</a></h2><p>What do you do if you are dealing with a legacy system, a big ball of mud? How do you get a taste of DDD there (assuming you still can employ iterative development approach, and have access to domain experts)?</p><p>Well, just because the legacy system aka. “the big ball of mud” exists, it does not mean you have to keep cramping it with new features, but rather, employ your context mapping techniques here. Draw a line around it and say, “this is my big ball of mud”, and after that draw a line around your new service and treat it as a separate bounded context.</p><p>As Eric puts it, it’s probably inevitable that your service will get enclosed by the big ball of mud eventually (since it will eat almost anything), but at least you had a nice run for a time.</p><h2 id=a-word-on-ddd-building-blocks>A word on DDD building blocks<a hidden class=anchor aria-hidden=true href=#a-word-on-ddd-building-blocks>#</a></h2><blockquote><p>Building blocks (Entities, Value Objects, Factories, Repositories …) are overemphasized! — Eric Evans</p></blockquote><p>Yes, you heard it right. Building blocks have gotten too much attention, but don’t get me wrong, they are still important and provide a great value. Building blocks are what they are. They are a means to an end, mere implementation details that help you implement strategic DDD patterns.</p><p>As Evans stated, he regrets putting the strategic patterns way back at the end of the book, which probably resulted in many people giving more importance to the tactical patterns because they come first or even worse, they get so caught up in the intricate implementation details of tactical patterns, they don’t even get to the most important part of the book.</p><p>The thing to take away is that building blocks provide you the tools to implement DDD, but you should give much more focus to strategic patterns, even more so because tactical patterns/building blocks will continue to evolve, some will become obsolete, new ones will be added (eg. Domain Events).</p><h2 id=aggregates>Aggregates<a hidden class=anchor aria-hidden=true href=#aggregates>#</a></h2><p>Aggregate represents a conceptual whole in the domain that is also consisted of other small parts (Value Objects and/or other Entities) and protects an always consistent invariant across all of them.</p><p>One question that pops up often is a concern that a lot of people have regarding the awkward cases where their aggregates have an invariant that crosses thousands of entities.</p><p>Since we can access a child entity only through its parent aggregate, do we load all of them each time we load an aggregate? Do we make use of lazy loading? Do we model this differently even though it’s a business invariant? If yes, what’s the correct model for this?</p><p>The bottom line is that OO is really not good at handling collections of objects, especially very large collections, which calls for loosening and “bending” the rules a bit in these cases.</p><p>The same applies if you have a small number of aggregates but have a lot of concurrent users that might be interacting with the aggregate at the same time.</p><p>In cases like these, you might consider modeling those entities as separate aggregate(s) and try enforcing the business invariant on a higher level. For example, in domain services, process managers/sagas etc…
In short, make the consistency an explicit concern of your domain instead of it being solved implicitly through the infrastructure.</p><p>As it turns out, another potential solution is related to another question/concern that keeps popping up when working on a project that makes use of <strong>CQRS</strong> as a standalone pattern or in a combination with <strong>Event Sourcing</strong>.</p><p><strong>Can write side query the read side?</strong></p><p>According to Greg Young, the answer is
<strong>yes, absolutely, there are cases when you simply have to</strong>, and one of those cases is related to the challenge we mentioned here.</p><p>I’d argue that even if you don’t face the aggregates/entities problem we describe here, there are a lot of cases where it’s OK to query the read side (I have certainly done it more than once).</p><p>It’s fairly easy to spot these opportunities because in majority (if not all) of the cases they tend to present themselves in a form of a specification pattern, but since you are using Event Sourcing or CQRS as a standalone pattern, you can’t really make use of them.
But luckily for you, specifications and CQRS are two competing/interchangeable patterns.</p><p>Rule of thumb would be to aim for very small and very specific projections which can provide you with a very specific answer to a very specific question which would be very cumbersome to implement by querying domain models.</p><p>Vaughn Vernon has a lot to say about aggregate design.
Check out his two-part Aggregate Design paper:</p><ul><li><a href=http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_1.pdf>Effective Aggregate Design Part I</a></li><li><a href=http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf>Effective Aggregate Design Part II</a></li></ul><p>I also highly recommend you check out his DDD book: <a href=https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577/>Implementing Domain-Driven Design</a></p><h2 id=ddd-in-a-modern-always-on-world>DDD in a modern “always on” world<a hidden class=anchor aria-hidden=true href=#ddd-in-a-modern-always-on-world>#</a></h2><p>Software applications outside of the enterprise world, in general, have quite different requirements in terms of performance, latency, responsiveness, and scalability. There was a fear that applying DDD patterns to these kinds of domains would not really be feasible due to the aforementioned constraints and the overhead that OOP with DDD applied would introduce.</p><p>This might have been a great obstacle to widespread DDD adoption, but luckily, applying DDD to these kinds of domains gave birth to a new approach (the ideas were there for centuries actually) towards applying DDD under the name of Event Sourcing and CQRS.</p><p>In short, Event Sourcing and it’s complementary pattern, CQRS gave us an extravagant revamp of DDD building blocks, and a way to employ DDD patterns through the use of Domain Events as first-class citizens and the sole source of truth in these kinds of systems, while at the same time allowing us to satisfy high throughput / high availability needs of those kinds of systems, by enabling us to scale reads and writes separately, and employ inter-service integration via Domain Events.</p><p>Event Sourcing also provides a stepping stone towards implementing DDD in a functional world, due to the immutable nature of its event streams (An aggregate state is a left fold of all of its events).</p><p>But meeting scalability demands of large distributed systems is not the only benefit of employing this kind of event-centric approach towards modeling our systems.</p><p>There are a number of other benefits of employing an event-first modeling approach:</p><ul><li>Explicitly modeling important domain events and formalizing them, forces domain experts to think in terms of the behavior of their system instead of in terms of its structure. This especially helps, since people tend to think in terms of their legacy systems, instead of focusing on the problem they are really trying to solve.</li><li>By modeling events, and focusing on the behaviors instead of nouns, even the domain experts get a different perspective on their domain and gain additional insight.</li><li>Event modeling forces temporal focus and makes time become a crucial factor (which it is)</li></ul><p>If any of these resonate with you I encourage you to check out <a href=https://www.eventstorming.com/>Event Storming</a> by Alberto Brandolini. Event Storming employs an event-centric approach in order to distill the domain.</p><p>I won’t go into detail here, but I will just mention that Event Storming has a number of different flavors you will find on the site and the <a href=https://www.eventstorming.com/book/>book</a> but, I would like to mention one more variant by Greg Young.</p><p>In his variant, you basically just take one single long-running business process end to end and model it using Event Storming in order to discover your service boundaries. This worked very well for me.</p><h2 id=event-sourcing-and-cqrs-misconceptionspain-points>Event Sourcing and CQRS misconceptions/pain points<a hidden class=anchor aria-hidden=true href=#event-sourcing-and-cqrs-misconceptionspain-points>#</a></h2><p>During one of his talks, Young focused on some recurring pain points/misconceptions that were coming up repeatedly regarding Event Sourcing and CQRS, and offered clarification and advice on how to approach these …. Here is a short recap.</p><blockquote><p>CQRS is not a top-level architecture!</p></blockquote><p>CQRS is a supporting pattern and you need to treat it as such. Don’t go crazy! Instead, apply it selectively to a few places.</p><blockquote><p>Commands must return void?!</p></blockquote><p>The bottom line is that it’s not about return values, it’s rather about side effects? It is perfectly OK for commands to return the list of errors example, instead of relying only on throwing exceptions (which is a bit of a bad practice anyway).</p><blockquote><p>Command vs Domain Event is not strictly a one on one relationship!</p></blockquote><p>An event does not necessarily have a corresponding command, nor does a command have exactly one corresponding event being published.
It is important to understand that there are always two sets of use cases. The commands coming in and the events coming out.</p><p>An event is not strictly a result of a command coming in. In event-centric architectures, this is commonplace to see, and the whole point of it is that events cause stuff to happen. A business process that resulted in publishing a domain event is often time triggered by another event without any commands.</p><blockquote><p>There is no such thing as one way / async Command</p></blockquote><p>The whole point of a command is that I have the ability to tell you No!</p><p>“Async” commands don&rsquo;t really give you that option, you just fire and forget, which is kind of defeating the purpose. They do not work well in the real world.</p><p>By accepting a command, it should mean that you validated it, you can execute it, you processed it and it’s done. Otherwise, what you really want is a downstream event processor.</p><blockquote><p>Don&rsquo;t write a CQRS / Event Sourcing framework. Period.</p></blockquote><p>I think we need to start realizing that you do not need a framework for everything. Frameworks have their place, but we need to put an end to framework-first mindset and instead, try to solve our problems with focused modules/libraries instead of relying on almost always “too generic” frameworks which tend to sprawl their tentacles all over our code base.</p><blockquote><p>We need better examples!</p></blockquote><p>As Greg puts it, we need better examples. Event Sourcing is hard, that’s a fact, and simple examples like simplified shopping cards don’t really do it justice.</p><p>Recommended training material:</p><ul><li><a href=https://www.amazon.com/Domain-Driven-Design-Distilled-Vaughn-Vernon/dp/0134434420>Domain-Driven Design Distilled</a></li><li><a href=https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577/>Implementing Domain-Driven Design</a></li><li><a href=https://www.eventstorming.com/>Event Storming</a></li><li><a href=https://leanpub.com/introducing_eventstorming>Event Storming Book</a></li><li><a href=https://www.amazon.com/Microservices-Patterns-examples-Chris-Richardson/dp/1617294543/>Microservices Patterns: With examples in Java</a></li><li><a href=https://www.confluent.io/blog/data-dichotomy-rethinking-the-way-we-treat-data-and-services/>Confluent Microservices blog series</a></li><li><a href=https://www.lightbend.com/learn/lightbend-reactive-architecture>Lightbend Courses</a></li><li><a href=https://www.infoq.com/presentations/systems-event-driven>How Events Are Reshaping Modern Systems</a></li></ul><p>This blog has also been published at <a href=https://tacta.io/en/news/a-decade-of-ddd-cqrs-and-event-sourcing/7>tacta.io</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://anes.io/tags/event-sourcing/>event sourcing</a></li><li><a href=https://anes.io/tags/ddd/>ddd</a></li><li><a href=https://anes.io/tags/cqrs/>cqrs</a></li><li><a href=https://anes.io/tags/event-modeling/>event modeling</a></li><li><a href=https://anes.io/tags/event-storming/>event storming</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share A Decade of DDD, CQRS and Event Sourcing on twitter" href="https://twitter.com/intent/tweet/?text=A%20Decade%20of%20DDD%2c%20CQRS%20and%20Event%20Sourcing&url=https%3a%2f%2fanes.io%2fposts%2fa-decade-of-ddd-cqrs-and-event-sourcing%2f&hashtags=eventsourcing%2cddd%2ccqrs%2ceventmodeling%2ceventstorming"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A Decade of DDD, CQRS and Event Sourcing on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fanes.io%2fposts%2fa-decade-of-ddd-cqrs-and-event-sourcing%2f&title=A%20Decade%20of%20DDD%2c%20CQRS%20and%20Event%20Sourcing&summary=A%20Decade%20of%20DDD%2c%20CQRS%20and%20Event%20Sourcing&source=https%3a%2f%2fanes.io%2fposts%2fa-decade-of-ddd-cqrs-and-event-sourcing%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A Decade of DDD, CQRS and Event Sourcing on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fanes.io%2fposts%2fa-decade-of-ddd-cqrs-and-event-sourcing%2f&title=A%20Decade%20of%20DDD%2c%20CQRS%20and%20Event%20Sourcing"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A Decade of DDD, CQRS and Event Sourcing on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fanes.io%2fposts%2fa-decade-of-ddd-cqrs-and-event-sourcing%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A Decade of DDD, CQRS and Event Sourcing on whatsapp" href="https://api.whatsapp.com/send?text=A%20Decade%20of%20DDD%2c%20CQRS%20and%20Event%20Sourcing%20-%20https%3a%2f%2fanes.io%2fposts%2fa-decade-of-ddd-cqrs-and-event-sourcing%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share A Decade of DDD, CQRS and Event Sourcing on telegram" href="https://telegram.me/share/url?text=A%20Decade%20of%20DDD%2c%20CQRS%20and%20Event%20Sourcing&url=https%3a%2f%2fanes.io%2fposts%2fa-decade-of-ddd-cqrs-and-event-sourcing%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://anes.io/>Anes Hasicic</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>