<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>ddd on Anes Hasicic</title><link>https://anes.io/tags/ddd/</link><description>Recent content in ddd on Anes Hasicic</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 16 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://anes.io/tags/ddd/index.xml" rel="self" type="application/rss+xml"/><item><title>Event Sourcing with Go and Hexagonal Architecture</title><link>https://anes.io/posts/event-sourcing-with-go-and-hexagonal-architecture/</link><pubDate>Thu, 16 Jun 2022 00:00:00 +0000</pubDate><guid>https://anes.io/posts/event-sourcing-with-go-and-hexagonal-architecture/</guid><description>Not long ago I have slowly started preparing material for a pragmatic hands-on book I’ve always wanted to write on the topic of event sourcing, where I would explore it in my own approachable way, applicable to any skill level while also spicing it up with golang, ports and adapters, tdd, testing, event driven architecture and good software engineering practices in general.
It’s still early days and I am still fleshing it out.</description></item><item><title>A Case for Event Sourcing</title><link>https://anes.io/posts/a-case-for-event-sourcing/</link><pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate><guid>https://anes.io/posts/a-case-for-event-sourcing/</guid><description>You must have heard these before:
Bad programmers worry about the code. Good programmers worry about data structures and their relationships. — Linus Torvalds
…Show me your data structures, and I won’t usually need your code; it’ll be obvious. — The Mythical Man-Month
Smart data structures and dumb code works a lot better than the other way around. — Eric S. Raymond
Of course, when dealing with software, it always depends but as a general rule I find these claims to be largely true.</description></item><item><title>Event Sourcing is not Event Streaming</title><link>https://anes.io/posts/event-sourcing-is-not-event-streaming/</link><pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate><guid>https://anes.io/posts/event-sourcing-is-not-event-streaming/</guid><description>I find it very unfortunate that there are so many negative experiences people have when attempting to implement Event Sourcing most of which turn out to be due to throwing too much infrastructure onto the problem, which as a general case doesn’t work most of the time in any context.
What does this mean?
You do not need an event-streaming platform like Kafka in order to implement Event Sourcing. (That comes later — if at all).</description></item><item><title>Modeling Domain Events</title><link>https://anes.io/posts/modeling-domain-events/</link><pubDate>Sat, 05 Mar 2022 00:00:00 +0000</pubDate><guid>https://anes.io/posts/modeling-domain-events/</guid><description>Domain Event is a powerful modeling tool. From a technical perspective domain event is implemented as a simple immutable data transfer object, but conceptually, domain event is much, much more than that.
Naming Domain Events There are only two hard things in Computer Science: cache invalidation and naming things. — Phil Karlton
Naming domain events is no different, but if we understand the nature of a domain event, combined with a few useful guidelines, it is more than manageable.</description></item><item><title>Missing the point with Microservices</title><link>https://anes.io/posts/missing-the-point-with-microservices/</link><pubDate>Sun, 20 Feb 2022 00:00:00 +0000</pubDate><guid>https://anes.io/posts/missing-the-point-with-microservices/</guid><description>By now, even the birds on the trees got the memo that microservices are not a catch-all magic pill that will fix all of your organizational and product issues seemingly caused by a monolithic way of thinking.
More often than not organizations fail spectacularly by carrying over this monolithic way of thinking when decomposing their systems towards more decoupled (hopefully) microservices architecture and end up having even more issues and higher incurred costs as compared to the good old monolith.</description></item><item><title>Domain Driven Design and Pattern Thinking</title><link>https://anes.io/posts/domain-driven-design-and-pattern-thinking/</link><pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate><guid>https://anes.io/posts/domain-driven-design-and-pattern-thinking/</guid><description>Design patterns are very useful things in general and they pop up a lot if you are applying DDD in an OOP context (If you’re there you are probably already applying Tactical DDD patterns).
One principle I want to emphasize here because I see so many violations of it, is the following: Don’t use pattern names when implementing a pattern. It’s amazing how people keep missing the point.
Applying this principle is actually very helpful in double checking if you are applying the right pattern to the right thing.</description></item><item><title>Let’s build a house</title><link>https://anes.io/posts/lets-build-a-house/</link><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><guid>https://anes.io/posts/lets-build-a-house/</guid><description>When talking about software, we often hear the term “architecture” mentioned a lot. That inevitably reminds us of buildings and construction. While this may be true up to some extent, there are a lot of discrepancies between the approaches we take towards architecting a building (a house for example) and a typical web application software system. Much more so if we employ agile practices while doing so (which I hope we all do).</description></item><item><title>Domain Driven Design and the art of Pushing Back</title><link>https://anes.io/posts/domain-driven-design-and-the-art-of-pushing-back/</link><pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate><guid>https://anes.io/posts/domain-driven-design-and-the-art-of-pushing-back/</guid><description>When talking about Domain Driven Design, the thing we hear most often is that it’s about the software being guided by the domain, which is true, but I argue that it’s just one side of the coin and cannot stand alone.
The other less emphasized aspect of it is the one where you actually try to understand the problem that the domain is trying to solve, it’s where you push back, challenge the status quo, try to understand the domain/problem itself and model towards first principles.</description></item><item><title>A Decade of DDD, CQRS and Event Sourcing</title><link>https://anes.io/posts/a-decade-of-ddd-cqrs-and-event-sourcing/</link><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><guid>https://anes.io/posts/a-decade-of-ddd-cqrs-and-event-sourcing/</guid><description>For those that haven’t really moved past the blue book…
DDD for many, including me, brought back the enjoyment of software development. Implementation becomes easy when you break down the domain. The bits and pieces suddenly start to “fit” together in a way they did not before, and the implementation itself becomes straight-forward which results in a simple, maintainable and easy to understand code that will outlive the development team itself.</description></item></channel></rss>